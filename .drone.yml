kind: pipeline
type: docker
name: terraform-pipeline

platform:
  os: linux
  arch: amd64

clone:
  disable: true

volumes:
  - name: terraform
    host:
      path: /mnt/apppooldisk/devappdata/drone-runners

steps:
- name: create_directories
  image: alpine:latest
  volumes:
    - name: terraform
      path: /workspace/terraform
  commands:
    - mkdir -p /workspace/terraform/${DRONE_REPO_OWNER}/${DRONE_REPO_NAME}/

- name: custom_clone
  image: docker:git
  network_mode: br1.201
  volumes:
    - name: terraform
      path: /workspace/terraform
  environment:
    GIT_REPO_URL:
      from_secret: GIT_REPO_URL
  commands:
    - if [ -d /workspace/terraform/${DRONE_REPO_OWNER}/${DRONE_REPO_NAME}/.git ]; then
        cd /workspace/terraform/${DRONE_REPO_OWNER}/${DRONE_REPO_NAME}/ && git fetch && git reset --hard origin/main;
      else
        git clone $GIT_REPO_URL /workspace/terraform/${DRONE_REPO_OWNER}/${DRONE_REPO_NAME}/;
      fi

# - name: terraform-plan
#   image: hashicorp/terraform:latest
#   network_mode: br1.201
#   volumes:
#     - name: terraform
#       path: /workspace/terraform
#   environment:
#     AWS_ACCESS_KEY_ID:
#       from_secret: AWS_ACCESS_KEY_ID
#     AWS_SECRET_ACCESS_KEY:
#       from_secret: AWS_SECRET_ACCESS_KEY
#     TF_VAR_SOURCE_SSH_NET:
#       from_secret: TF_VAR_SOURCE_SSH_NET
#     TF_VAR_PUBLIC_KEY:
#       from_secret: TF_VAR_PUBLIC_KEY
#     TF_VAR_HOME_IP:
#       from_secret: TF_VAR_HOME_IP
#     TF_VAR_CLOUDFLARE_API_TOKEN:
#       from_secret: CLOUDFLARE_API_TOKEN
#     TF_VAR_CLOUDFLARE_ZONE_ID:
#       from_secret: CLOUDFLARE_ZONE_ID
#   commands:
#     - cd /workspace/terraform/${DRONE_REPO_OWNER}/${DRONE_REPO_NAME}/
#     - terraform init
#     - terraform plan


- name: terraform-apply
  image: hashicorp/terraform:latest
  network_mode: br1.201
  volumes:
    - name: terraform
      path: /workspace/terraform
  environment:
    AWS_ACCESS_KEY_ID:
      from_secret: AWS_ACCESS_KEY_ID
    AWS_SECRET_ACCESS_KEY:
      from_secret: AWS_SECRET_ACCESS_KEY
    TF_VAR_SOURCE_SSH_NET:
      from_secret: TF_VAR_SOURCE_SSH_NET
    TF_VAR_PUBLIC_KEY:
      from_secret: TF_VAR_PUBLIC_KEY
    TF_VAR_HOME_IP:
      from_secret: TF_VAR_HOME_IP
    CLOUDFLARE_API_TOKEN:
      from_secret: CLOUDFLARE_API_TOKEN
    CLOUDFLARE_EMAIL:
      from_secret: CLOUDFLARE_EMAIL
    TF_VAR_CLOUDFLARE_API_TOKEN:
      from_secret: CLOUDFLARE_API_TOKEN
    TF_VAR_CLOUDFLARE_ZONE_ID:
      from_secret: CLOUDFLARE_ZONE_ID
  commands:
    - apk add --no-cache jq
    - cd /workspace/terraform/${DRONE_REPO_OWNER}/${DRONE_REPO_NAME}/
    - terraform init
    - terraform apply -auto-approve
    - terraform apply -target=aws_lb.istio_ingress_nlb -target=aws_lb_target_group_attachment.istio_http_attachment -target=aws_lb_target_group_attachment.istio_https_attachment -target=aws_lb_target_group_attachment.argocd_http_attachment -auto-approve

- name: kubectl-apply
  image: alpine:latest
  environment:
    AWS_ACCESS_KEY_ID:
      from_secret: AWS_ACCESS_KEY_ID
    AWS_SECRET_ACCESS_KEY:
      from_secret: AWS_SECRET_ACCESS_KEY
    CLOUDFLARE_API_TOKEN:
      from_secret: CLOUDFLARE_API_TOKEN
    CLOUDFLARE_EMAIL:
      from_secret: CLOUDFLARE_EMAIL
    TF_VAR_CLOUDFLARE_API_TOKEN:
      from_secret: CLOUDFLARE_API_TOKEN
    TF_VAR_CLOUDFLARE_ZONE_ID:
      from_secret: CLOUDFLARE_ZONE_ID
  volumes:
    - name: terraform
      path: /workspace/terraform
  commands:
    # Install dependencies
    - apk add --no-cache bash curl unzip python3 py3-pip git openssl
    # Install AWS CLI
    - pip install awscli --break-system-packages
    # Install kubectl
    - curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
    - chmod +x ./kubectl
    - mv ./kubectl /usr/local/bin/
    # Install Istio CLI (istioctl)
    - curl -L https://istio.io/downloadIstio | sh -
    - mv istio-* /usr/local/istio
    - export PATH=$PATH:/usr/local/istio/bin

    # Configure kubectl for the cluster
    - aws eks update-kubeconfig --region us-east-1 --name eks-drewpy
    - export KUBECONFIG=/root/.kube/config
    - kubectl wait --for=condition=Ready nodes --all --timeout=300s


    # Install Cert-Manager
    - kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.16.2/cert-manager.crds.yaml
    - kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.16.2/cert-manager.yaml
    - kubectl wait --for=condition=available --timeout=300s deployment/cert-manager -n cert-manager
    - kubectl wait --for=condition=available --timeout=300s deployment/cert-manager-webhook -n cert-manager
    - kubectl wait --for=condition=available --timeout=300s deployment/cert-manager-cainjector -n cert-manager

    # Create Secrets for Cert-Manager
    - kubectl create secret generic cloudflare-api-token --from-literal=api-token=$CLOUDFLARE_API_TOKEN -n cert-manager || true

     # Replace the placeholder with the email secret
    - sed -i "s/{{EMAIL_PLACEHOLDER}}/${CLOUDFLARE_EMAIL}/" /workspace/terraform/${DRONE_REPO_OWNER}/${DRONE_REPO_NAME}/cert-manager/cluster-issuer.yaml
      
    # Add ClusterIssuer for Let's Encrypt
    - kubectl apply -f /workspace/terraform/${DRONE_REPO_OWNER}/${DRONE_REPO_NAME}/cert-manager/cluster-issuer.yaml


    # Create Kubernetes secret for the egress gateway certificate
    - kubectl create namespace istio-system || true
    
    # # Generate a private key
    # - openssl genrsa -out egress-gateway.key 2048
    # - openssl genrsa -out ingress-gateway.key 2048

    # # Generate a certificate signing request (CSR)
    # - openssl req -new -key egress-gateway.key -out egress-gateway.csr -subj "/CN=egress-gateway/O=example"
    # - openssl req -new -key ingress-gateway.key -out ingress-gateway.csr -subj "/CN=ingress-gateway/O=example"

    # # Self-sign the certificate (or use a CA to sign it)
    # - openssl x509 -req -in egress-gateway.csr -signkey egress-gateway.key -out egress-gateway.crt -days 365
    # - openssl x509 -req -in ingress-gateway.csr -signkey ingress-gateway.key -out ingress-gateway.crt -days 365

    # - kubectl create secret tls egress-gateway-cert --cert=egress-gateway.crt --key=egress-gateway.key -n istio-system || true
    # - kubectl create secret tls ingress-gateway-cert --cert=ingress-gateway.crt --key=ingress-gateway.key -n istio-system || true


    # 1. Create namespaces
    - kubectl apply -f /workspace/terraform/${DRONE_REPO_OWNER}/${DRONE_REPO_NAME}/kubernetes/namespaces/

    # 2. Install Istio
    - kubectl -n kube-system rollout status deploy/coredns --timeout=60s
    - istioctl install -f /workspace/terraform/${DRONE_REPO_OWNER}/${DRONE_REPO_NAME}/kubernetes/istio-config.yaml --skip-confirmation
    - kubectl -n istio-system rollout status deploy/istiod --timeout=300s
    - kubectl -n istio-system rollout status deploy/ingress-gateway --timeout=300s


    # 3. Install ArgoCD
    - kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
    - kubectl patch configmap argocd-cmd-params-cm -n argocd --type merge -p '{"data":{"server.insecure":"true"}}'
    - kubectl wait deployment -n argocd argocd-server --for=condition=Available --timeout=300s

    # 4. Apply ArgoCD ConfigMap and RBAC
    - kubectl apply -f /workspace/terraform/${DRONE_REPO_OWNER}/${DRONE_REPO_NAME}/argocd/argocd-config.yaml
    - kubectl apply -f /workspace/terraform/${DRONE_REPO_OWNER}/${DRONE_REPO_NAME}/argocd/argocd-rbac.yaml

    # 5. Add ArgoCD Applications
    - kubectl apply -f /workspace/terraform/${DRONE_REPO_OWNER}/${DRONE_REPO_NAME}/argocd/apps/

    # 6. Rest of kubernetes manifests
    - kubectl apply -f /workspace/terraform/${DRONE_REPO_OWNER}/${DRONE_REPO_NAME}/kubernetes/services/
    - kubectl apply -f /workspace/terraform/${DRONE_REPO_OWNER}/${DRONE_REPO_NAME}/kubernetes/deployments/
    - kubectl apply -f /workspace/terraform/${DRONE_REPO_OWNER}/${DRONE_REPO_NAME}/kubernetes/gateways/
    - kubectl apply -f /workspace/terraform/${DRONE_REPO_OWNER}/${DRONE_REPO_NAME}/kubernetes/virtual-services/

    # 5. Wait and validate
    # - kubectl wait deployment -n namespace1 app1 --for=condition=Available --timeout=300s
    - kubectl wait deployment -n namespace2 app2 --for=condition=Available --timeout=300s
    - kubectl get nodes

# - name: terraform-destroy
#   image: hashicorp/terraform:latest
#   network_mode: br1.201
#   volumes:
#     - name: terraform
#       path: /workspace/terraform
#   environment:
#     AWS_ACCESS_KEY_ID:
#       from_secret: AWS_ACCESS_KEY_ID
#     AWS_SECRET_ACCESS_KEY:
#       from_secret: AWS_SECRET_ACCESS_KEY
#     TF_VAR_SOURCE_SSH_NET:
#       from_secret: TF_VAR_SOURCE_SSH_NET
#     TF_VAR_PUBLIC_KEY:
#       from_secret: TF_VAR_PUBLIC_KEY
#     TF_VAR_HOME_IP:
#       from_secret: TF_VAR_HOME_IP
#   commands:
#     - cd /workspace/terraform/${DRONE_REPO_OWNER}/${DRONE_REPO_NAME}/
#     - terraform init
#     - terraform destroy -target=aws_cloudwatch_log_group.vpc_flow_log_group -auto-approve
#     - terraform destroy -auto-approve

trigger:
  branch:
  - main
  event:
  - push